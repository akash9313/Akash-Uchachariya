$date
	Tue Feb 03 11:35:46 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module BoothMultiplier_tb $end
$var wire 1 ! q0 $end
$var wire 1 " sftQ $end
$var wire 1 # sftA $end
$var wire 1 $ qm1 $end
$var wire 1 % ldcnt $end
$var wire 1 & eqz $end
$var wire 1 ' done $end
$var wire 1 ( decr $end
$var wire 1 ) clrq $end
$var wire 1 * clrff $end
$var wire 1 + clrA $end
$var wire 1 , addsub $end
$var wire 1 - LdQ $end
$var wire 1 . LdM $end
$var wire 1 / LdA $end
$var reg 1 0 clk $end
$var reg 16 1 data_in [15:0] $end
$var reg 1 2 start $end
$scope module BM $end
$var wire 1 0 clk $end
$var wire 1 3 clrQ $end
$var wire 16 4 data_in [15:0] $end
$var wire 1 ! q0 $end
$var wire 1 " sftQ $end
$var wire 1 # sftA $end
$var wire 1 $ qm1 $end
$var wire 1 % ldcnt $end
$var wire 1 & eqz $end
$var wire 1 ( decr $end
$var wire 5 5 count [4:0] $end
$var wire 1 ) clrq $end
$var wire 1 * clrff $end
$var wire 1 + clrA $end
$var wire 1 , addsub $end
$var wire 16 6 Z [15:0] $end
$var wire 16 7 Q [15:0] $end
$var wire 16 8 M [15:0] $end
$var wire 1 - LdQ $end
$var wire 1 . LdM $end
$var wire 1 / LdA $end
$var wire 16 9 A [15:0] $end
$scope module AR $end
$var wire 1 0 clk $end
$var wire 1 : s_in $end
$var wire 1 # sft $end
$var wire 1 / ld $end
$var wire 16 ; din [15:0] $end
$var wire 1 + clr $end
$var reg 16 < dout [15:0] $end
$upscope $end
$scope module AS $end
$var wire 16 = in1 [15:0] $end
$var wire 16 > in2 [15:0] $end
$var wire 1 , addsub $end
$var reg 16 ? out [15:0] $end
$upscope $end
$scope module CN $end
$var wire 1 0 clk $end
$var wire 1 % ldcnt $end
$var wire 1 ( decr $end
$var reg 5 @ count [4:0] $end
$upscope $end
$scope module MR $end
$var wire 1 0 clk $end
$var wire 16 A din [15:0] $end
$var wire 1 . ld $end
$var reg 16 B dout [15:0] $end
$upscope $end
$scope module QM1 $end
$var wire 1 0 clk $end
$var wire 1 C d $end
$var wire 1 * clr $end
$var reg 1 $ q $end
$upscope $end
$scope module QR $end
$var wire 1 0 clk $end
$var wire 1 3 clr $end
$var wire 16 D din [15:0] $end
$var wire 1 E s_in $end
$var wire 1 " sft $end
$var wire 1 - ld $end
$var reg 16 F dout [15:0] $end
$upscope $end
$upscope $end
$scope module CL $end
$var wire 1 ! Q0 $end
$var wire 1 0 clk $end
$var wire 1 & eqz $end
$var wire 1 $ qm1 $end
$var wire 1 2 start $end
$var reg 1 / LdA $end
$var reg 1 . LdM $end
$var reg 1 - LdQ $end
$var reg 1 , addsub $end
$var reg 1 + clrA $end
$var reg 1 ) clrQ $end
$var reg 1 * clrff $end
$var reg 1 ( decr $end
$var reg 1 ' done $end
$var reg 1 % ldcnt $end
$var reg 1 # sftA $end
$var reg 1 " sftQ $end
$var reg 3 G state [2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx G
bx F
xE
bx D
xC
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
x:
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
z3
x2
bx 1
00
x/
x.
x-
x,
x+
x*
x)
x(
x'
x&
x%
x$
x#
x"
z!
$end
#5
0'
0.
0"
0*
0)
0-
0#
0+
0/
b0 G
10
#7
12
#10
00
b11 1
b11 4
b11 A
b11 D
#15
1-
1%
1*
1+
b1 G
10
#20
00
#25
0E
0:
1C
b0 9
b0 <
b0 =
b11 7
b11 F
0&
b1111 5
b1111 @
10
#26
0$
#27
0-
1.
0%
0*
0+
b10 G
#30
00
b111 1
b111 4
b111 A
b111 D
#35
b111 6
b111 ;
b111 ?
1(
1"
1#
b111 8
b111 >
b111 B
b101 G
10
#36
1$
#40
00
#45
b1 7
b1 F
b1110 5
b1110 @
10
#50
00
#55
0C
b1101 5
b1101 @
b0 7
b0 F
10
#56
0$
#60
00
#65
b1100 5
b1100 @
10
#70
00
#75
b1011 5
b1011 @
10
#80
00
#85
b1010 5
b1010 @
10
#90
00
#95
b1001 5
b1001 @
10
#100
00
#105
b1000 5
b1000 @
10
#110
00
#115
b111 5
b111 @
10
#120
00
#125
b110 5
b110 @
10
#130
00
#135
b101 5
b101 @
10
#140
00
#145
b100 5
b100 @
10
#150
00
#155
b11 5
b11 @
10
#160
00
#165
b10 5
b10 @
10
#170
00
#175
b1 5
b1 @
10
#180
00
#185
1&
b0 5
b0 @
10
#187
1'
b110 G
#188
